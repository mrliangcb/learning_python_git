
# 2章.pandas用法

```python
import numpy as np
import pandas as pd
import os
```

## 1.Series
pandas表格，每一列都是一个series ,可以由list或者nparray产生  一个series有 value值，有行标序号
### (1)创建series 单个列  
(1.1)由list创建series:  
```python
se=pd.Series([4,3,6,10],index=['a','b','c','d'])  #index为行序号
print(a)
print(se.values)
print(se.index)
```
values : 获得list形式的内容  
(1.2)由dict创建series:  
```python
se2={'liming':25,'wangwu':35,'xiaoming':19} 
												
index=['china','wangwu','france']  #这是显示设置,
se2=pd.Series(se2,index) #根据字典生成series，然后选择一部分显示
#series的时候，value只有一个。而dataframe的时候value是一个list  
#liming wangwu就是index,也是key
```
结果为:  
```python
china      NaN
wangwu    35.0
france     NaN
dtype: float64
```


### (2)索引方法  
```python
se['a']  
se[['a']]  
```
维数与返回类型的关系 : 二维表示与自己相同的类型，一维表示比自己低的类型  
从低到高 : np或者list   series  dataframe  

条件索引:  
```python
se[se>0]
```
上面相当于se[[true,false]]里面是判断的结果bool型  

判断:  
```python
panduan='a' in se  
```
返回true  false

查找缺失值  
pd.isnull(se3).index.tolist() #获得行标，之后再根据行标做操作  
pd.isnull(se3)这部分是得到bool型series  

### (3)修改series
(3.1) 填充缺失   
.fillna()  #可以是value，或者数组，series  

(3.2) 修改行标
se3.index=['a','b','c']  #要把全部行标写出来
```
a    25
b    35
c    19
dtype: int64
```

se3.reindex(['a','b'],fill_value=0) #选择行标来显示行，缺失的填充0  
```
a    25
b    35
dtype: int64
```

(3.3) 

## 2.dataframe表格  

### (1) 创建  
从np创建df:  
```py
a=np.array([[1,2,3],[4,5,6],[7,8,9]])  
index=['a','b','c']  
column=['ming','wang','liang']  
df1=pd.DataFrame(a,index=['a','b','c'],columns=column)  
```

print(df1)
```
   ming  wang  liang
a     1     2      3
b     4     5      6
c     7     8      9
```

给行和列名加一个统一的名字  左上角  
df1.index.name='name'  
df1.columns.name='data'  

df1.reindex([1,'a','b']) #选择显示的顺序和项目  
df1.reindex(columns=[1,'xiaoming','liming']) #选择显示的顺序和项目  

### (2) 索引  
```py
df1.values  #返回一个二维的np  
df1['age']  #取出age这一列 一维的，所以返回series  
df1[['age']]  #返回df  
print(df1[['age','score']])  #取多行  
df1.loc[:,['age','score']]  #这种方法最常用，返回df  
df1.ix[['liming'],['age']] #少用这种


``

### (3) 修改    
index的不可修改性，不能单独修改  
df[]判断和修改值不能一步做完，要分开，先根据条件获得行标list，然后再对查找list进行修改，删除  
```py
df1['age']=1 #对整一列赋1  
df1['age']=[32,40,19]  #批量赋值  可以np.list,series  



```

### (4) 删除    
```py
del df1['birth'] #删除列

```

### (5) 文件打开 
**重点**   
(1)方法一:用pandas读  txt或者csv  

```py
path=r'.\test.txt'  
df1 = pd.read_csv(path,nrows=None)  
# 遇到逗号算一个列分割，遇到\n转下一行
- 可添加属性: 
> converters = {u'a':str,u'b':str} 对于'a','b'列，指定value为str类型 如果没有conver，则会自动转为float或者int
> dtype=str 指定全部value都是str型  对于0001这种数据，如果不设置str，则读成1
> names=["a","b","c"]  定义列名  建立df的时候用的是columns
> nrows=None  #取前面多少行
> index_col=0 表示读进来的内容没有行标    
> sep=',' 逗号作为分隔符  遇到逗号算一个列分割
> header=None  指的是说明这个文件第一行就是数据，没有列名。默认是有的，就会把第一行当做列名
> 
```

```py
pd.read_table(r'',encoding='ansi')  
# encoding='utf8'

pd.read_excel()   这种是读标准的excel文件，非逗号空格符的  csv文件是自带逗号作为分隔  
```
(2)方法二:用open读   
```py
with open(r'.\test.txt', 'r') as f:
    lines = f.readlines() #每行作读作一个str ，['第一行','第二行']
    print(lines)
    tokens = [i.rstrip('\n').split(',') for i in lines] #rstrip('内容') 删除字符串末尾的'内容'
    print(tokens) 
	
pd.DataFrame(tokens[1:],columns=tokens[0])

# tokens0 = [i.rstrip('\n').split(',')[0] for i in lines]  只取出第一列  
# 经过split,  a=[[一行],[二行],['1','2']]
# idx_label = dict((int(idx), label) for idx, label in tokens)#创建字典，数字：‘名字’
```

(3)读入文件后，查看属性 
```py
print('1.读前5行',df1.head(5))#tail看尾巴
print('\n2.形状',df1.shape)
print('\n3.有哪些列:',df1.columns)
print('\n4.每个列的数据类型:',df1.columns)
print('\n5.读values',df1.values) #回到list 
```














